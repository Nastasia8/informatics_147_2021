// Гурьянов Илья, гр. 1/147.
// Задание №5, номер 2.
// Программа переводит введённое пользователем целое число из 10 с.с. в 2, 8 и 16 системы счисления.

#include <iostream>
#include <Windows.h>
#include <cmath>

using namespace std;

int main()
{    
    // Локализация (отображение кириллицы в консоли)
    SetConsoleCP(65001);
    SetConsoleOutputCP(65001);

    float number; // number - число в 10 с.с., вводимое пользователем, тип float
    int NumSys = 2; // NumSys - основание системы счисления (numeral system)
    bool trigger = false; // trigger - триггер (true/false) для цикла while
    
    // "Защита от дурака"
    while (trigger == false)
    {
        cout << "Введите число в 10 с.с.: ";
        cin >> number;
        if (!cin.fail()) // проверка на флаг ошибки потока
        {
            if (number >= 0 && (float)((int)number) == number) // число >= 0 и целое
            {
                trigger = true;
                cout << "Введённое число: " << number << endl;
            }
            if (number > 0 && (float)((int)number) != number) // число > 0, но дробное 
            {
                trigger = true;
                cout << "Программа не умеет переводить дробные числа. Дробная часть числа откинута." << endl;
                cout << "Введённое число: " << (int)number << endl;
            }
            if (number < 0) // число < 0
            {
                cout << "Введите положительное число." << endl;
            }
        }
        else
        {
            // Почему после ввода букв, while уходит в бесконечный цикл и не спрашивает повторно cin >> number? Поэтому пришлось написать exit(1)
            // cin.clear();
            cout << "Ошибка." << endl;
            exit(1);
        }
    }

    int numberint = (int)number; // numberint - то же самое число в 10 с.с., но обрезается дробная часть, если пользователь ввёл число с ней
    int k2, k8, k16; // k2, k8, k16 - количество цифр в представлении числа во 2, 8, 16 с.с. соответственно
    if (numberint != 0)
    {
        // Вычисляем таким способом количество цифр. Вычисляем логарифм от (numberint) по основанию нужной системы счисления
        // (т.е. выясняем сколько раз число numberint можно поделить на основание) и добавляем ещё единичку.
        k2 = trunc( log(numberint) / log(2) ) + 1;
        k8 = trunc( log(numberint) / log(8) ) + 1;
        k16 = trunc( log(numberint) / log(16) ) + 1;
    }
    else
    {
        // Т.к. логарифма от нуля не существует, делаем дополнительное условие. Это на случай если пользователь введёт ноль. 
        k2 = k8 = k16 = 1; 
    }

    int Arr2[k2]; // Arr2 - массив для цифр числа в 2 с.с.
    int Arr8[k8]; // Arr8 - массив для цифр числа в 8 с.с.
    char Arr16[k16]; // Arr16 - массив для цифр числа в 16 с.с. (тип char, т.к. используем буквы в записи числа)
    int quotient; // quotient - частное (результат деления числа в 10 с.с. на основание нужной системы счисления)
    int remainder; // remainder - остаток от деления
    int k = k2; // k - текущее количество цифр числа в нужной системе счисления, нужно для цикла.

    // Цикл перевода введённого числа в нужные системы счисления. Идёт по порядку: 2 с.с., 8 с.с. и 16 с.с.
    for (int i = 0; i < 3; i ++)
    {
        quotient = numberint;
        if (i == 1) // на второй итерации основного цикла вычисляется 8 с.с.
        {
            NumSys = 8;
            k = k8;
        }
        if (i == 2) // на третьей итерации основного цикла вычисляется 16 с.с.
        {
            NumSys = 16;
            k = k16;
        }
            // Цикл вычисления цифр числа в нужной системе счисления
            for (int i = 0; i < k; i ++)
            {
                remainder = quotient % NumSys; // остаток от деления на основание с.с.
                quotient = quotient / NumSys; // частное (целая часть)
                
                // Записываем в нужный массив полученный остаток
                if (NumSys == 2)
                {
                    Arr2[i] = remainder;
                }
                if (NumSys == 8)
                {
                    Arr8[i] = remainder;
                }
                else // массив с 16 с.с., если остаток >= 10 записываем нужную букву
                {
                    if (remainder == 10)
                    {
                        Arr16[i] = 'A';
                    }
                    else if (remainder == 11)
                    {
                        Arr16[i] = 'B';
                    }
                    else if (remainder == 12)
                    {
                        Arr16[i] = 'C';
                    }
                    else if (remainder == 13)
                    {
                        Arr16[i] = 'D';
                    }
                    else if (remainder == 14)
                    {
                        Arr16[i] = 'E';
                    }
                    else if (remainder == 15)
                    {
                        Arr16[i] = 'F';
                    }
                    else
                    {
                        // Костыльчик. "Преобразование" int в char. Работает только для чисел (цифр) от 0 до 9, а нам больше и не надо.
                        Arr16[i] = '0' + remainder;  // или Arr16[i] = (char)(((int)'0')+remainder); - то же самое
                        // ASCII 48 - это символ '0', коды 48-57 символы цифр (0-9)
                    }
                }
            }
    }

    // Вывод массивов с полученными цифрами чисел в нужной системе счисления "задом наперёд".
    cout << "2 с.с.: ";
    for (int i = k2 - 1; i >= 0; i --)
    {
        cout << Arr2[i];
    }
    cout << "\n" << "8 с.с.: ";
    for (int i = k8 - 1; i >= 0; i --)
    {
        cout << Arr8[i];
    }
    cout << "\n" << "16 с.с.: ";
    for (int i = k16 - 1; i >= 0; i --)
    {
        cout << Arr16[i];
    }
    cout << "\n";

    return 0;
}