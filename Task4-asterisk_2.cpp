// Гурьянов Илья, гр. 1/147.
// Задание №4*, номер 2, вариант 6.            (в названии программы 'asterisk' с английского значит "звёздочка" (знак *))
// Программа аппроксимирует таблично заданную функцию (т.н. экспериментальные данные) линейной и квадратичной функциями с помощью метода наименьших квадратов (МНК).
// На консоль выводятся таблицы расчётов, полученные уравнения и невязки.

// Если использовать экспериментальные данные из методчки и сверить полученные данные из моей программы и полученные данные в методичке,
// то получаются небольшые расхождения, начиная с подсчета обратной матрицы для квадратичной функции и так далее. Следовательно, конечные коэффициенты
// квадратичной функции и её невязка отличаются от тех, что в методички (погрешность не более 0.05). Скорее всего, погрешность нарастает из-за неточности вычислений с числами с плавающей точкой.

#include <iostream>
#include <Windows.h>
#include <cmath>
#include <iomanip>

using namespace std;

int main()
{
    // Локализация (отображение кириллицы в консоли)
    SetConsoleCP(65001);
    SetConsoleOutputCP(65001);

    // Это экспериментальные данные из примера из методички. Использовать для проверки правильности работы программы и сверки выходных данных с методичкой. Следовательно, строчку 27 (ArrXY[n][2]) отключить.
    // float ArrXY[8][2] = { {0.5, 0.705}, {0.6, 0.495}, {0.7, 0.426}, {0.8, 0.357}, {0.9, 0.368}, {1.0, 0.406}, {1.1, 0.549}, {1.2, 0.768} };

    int n = 8; // n - количество пар (Xi, Yi) в таблице значений Xi и Yi нашей(их) таблично заданной функции (экспериментальных данных)
    float ArrXY[n][2] = { {2.1, 1.752}, {2.3, 1.762}, {2.5, 1.777}, {2.7, 1.797}, {2.9, 1.821}, {3.1, 1.850}, {3.3, 1.884}, {3.5, 1.944} }; // ArrXY - массив с экспериментальными данными, пары (Xi, Yi)
    float TotalX = 0; // TotalX - сумма всех Xi
    float TotalY = 0; // TotalY - сумма всех Yi
    float Xpow2[n]; // Xpow2 - массив с Xi^2
    float TotalXpow2 = 0; // TotalXpow2 - сумма всех Xi^2
    float Xpow3[n]; // Xpow3 - массив с Xi^3
    float TotalXpow3 = 0; // TotalXpow3 - сумма всех Xi^3
    float Xpow4[n]; // Xpow4 - массив с Xi^4
    float TotalXpow4 = 0; // TotalXpow4 - сумма всех Xi^4
    float ProductXY[n]; // ProductXY - массив с произведением Xi на Yi (Xi * Yi)
    float TotalProductXY = 0; // TotalProductXY - сумма всех произведений Xi на Yi (Xi * Yi)
    float ProductXpow2Y[n]; // ProductXpow2Y - массив с произведением Xi^2 на Y (Xi^2 * Y)
    float TotalProductXpow2Y = 0; // TotalProductXpow2Y - сумма всех произведений Xi^2 на Y (Xi^2 * Y)
    float MatrixLin_1[2][2]; // MatrixLin_1 [строка][столбец] - матрица (2x2) коэффициентов линейной системы для линейной (linear) функции
    float MatrixLin_2[2]; // MatrixLin_2 - вектор-столбец (матрица 2x1) свободных членов для линейной фцнкции
    float MatrixLin_3[2][2]; // MatrixLin_3 - обратная матрица (2x2) (к MatrixLin_1) для линейной функции
    float MatrixLin_4[2]; // MatrixLin_4 - вектор-столбец коэффициентов полинома для линейной функции
    float Lin_Y[n]; // Lin_Y - массив с 'Yi выч.' (Yi вычисленное) для линейной функции (т.е. решения Yi = A*Xi + B, где A и B - полученные коэффициенты полинома)
    float Lin_DeltaY[n]; // Lin_DeltaY - массив с DeltaYi ('Delta Yi' = Yi - 'Yi выч.'), т.е. (Yi экспериментальное (табличное) - Yi вычисленное) для линейной функции
    float Lin_DeltaYpow2[n]; // Lin_DeltaYpow2 - массив с (DeltaYi)^2 для линейной функции
    float Residual_Lin = 0; // Residual_Lin - невязка (residual) для линейной функции
    float MatrixQuad_1[3][3]; // MatrixQuad_1 - матрица (3x3) коэффициентов линейной системы для квадратичной (quadratic) функции
    float MatrixQuad_2[3]; // MatrixQuad_2 - вектор-столбец (матрица 3x1) свободных членов для квадратичной функции
    float MatrixQuad_3[3][3]; // MatrixQuad_3 - обратная матрица (3x3) (к MatrixQuad_1) для квадратичной функции
    float MatrixQuad_4[3]; // MatrixQuad_4 - вектор-столбец коэффициентов полинома для квадратичной функции
    float Quad_Y[n]; // Quad_Y - массив с 'Yi выч.' (Yi вычисленное) для квадратичной функции (т.е. решения Yi = A*(Xi)^2 + B*Xi + C; где A, B, C - полученные коэффициенты полинома)
    float Quad_DeltaY[n]; // Quad_DeltaY - массив с DeltaYi ('Delta Yi' = Yi - 'Yi выч.'), т.е. (Yi экспериментальное (табличное) - Yi вычисленное) для квадратичной функции
    float Quad_DeltaYpow2[n]; // Quad_DeltaYpow2 - массив с (DeltaYi)^2 для квадратичной функции
    float Residual_Quad = 0; // Residual_Quad - невязка для квадратичной функции

    // Этап 1. Аппроксимация экспериментальных данных линейной функцией.

    // Эти данные общие и для линейной функции, и для квадратичной функции.
    for (int i = 0; i < n; i ++)
    {
        TotalX += ArrXY[i][0]; // вычисление суммы всех Xi
        TotalY += ArrXY[i][1]; // вычисление суммы всех Yi
        Xpow2[i] = pow(ArrXY[i][0], 2); // вычисление и заполнение массива с Xi^2
        TotalXpow2 += Xpow2[i]; // вычисление суммы всех Xi^2
        Xpow3[i] = pow(ArrXY[i][0], 3); // вычисление и заполнение массива с Xi^3
        TotalXpow3 += Xpow3[i]; // вычисление суммы всех Xi^3
        Xpow4[i] = pow(ArrXY[i][0], 4); // вычисление и заполнение массива с Xi^4
        TotalXpow4 += Xpow4[i]; // вычисление суммы всех Xi^4
        ProductXY[i] = ArrXY[i][0] * ArrXY[i][1]; // вычисление и заполнение массива с (Xi * Yi)
        TotalProductXY += ProductXY[i]; // вычисление суммы всех (Xi * Yi)
        ProductXpow2Y[i] = pow(ArrXY[i][0], 2) * ArrXY[i][1]; // вычисление и заполнение массива с (Xi^2 * Y)
        TotalProductXpow2Y += ProductXpow2Y[i]; // вычисление суммы всех (Xi^2 * Y)
    }

    // Заполняем матрицу коэффициентов линейной системы для линейной функции
    MatrixLin_1[0][0] = TotalXpow2;
    MatrixLin_1[0][1] = MatrixLin_1[1][0] = TotalX;
    MatrixLin_1[1][1] = n;

    // Заполняем вектор-столбец свободных членов для линейной функции
    MatrixLin_2[0] = TotalProductXY;
    MatrixLin_2[1] = TotalY;

    // Создаём и заполняем вспомогательную матрицу (2x2) с алгебраическими дополнениями каждого элемента исходной матрицы MatrixLin_1. Это нужно для вычисления обратной матрицы к матрице MatrixLin_1
    float MatrixLin_1_A[2][2];  // MatrixLin_1_A - вспомогательная матрица с алгебраическими дополнениями каждого элемента исходной матрицы MatrixLin_1
    MatrixLin_1_A[0][0] = MatrixLin_1[1][1];
    MatrixLin_1_A[0][1] = (-1) * MatrixLin_1[1][0];
    MatrixLin_1_A[1][0] = (-1) * MatrixLin_1[0][1];
    MatrixLin_1_A[1][1] = MatrixLin_1[0][0];
    // Вычисляем определитель (determinant) матрицы MatrixLin_1. Это нужно для вычисления обратной матрицы к матрице MatrixLin_1
    float MatrixLin_1_det = MatrixLin_1[0][0] * MatrixLin_1[1][1] - MatrixLin_1[0][1] * MatrixLin_1[1][0]; // MatrixLin_1_det - определитель матрицы MatrixLin_1

    // Вычисляем обратную матрицу (2x2) (к MatrixLin_1) для линейной функции
    for (int i = 0; i < 2; i ++)
    {
        for (int k = 0; k < 2; k ++)
        {
            MatrixLin_3[i][k] = MatrixLin_1_A[i][k] / MatrixLin_1_det;
        }
    }

    // Вычисляем вектор-столбец коэффициентов полинома для линейной функции посредством перемножения обратной матрицы MatrixLin_3 на вектор-столбец свободных членов MatrixLin_2
    for (int i = 0; i < 2; i ++)
    {
            MatrixLin_4[i] = MatrixLin_3[i][0] * MatrixLin_2[0] + MatrixLin_3[i][1] * MatrixLin_2[1];
    }

    // Вычисляем массив с 'Yi выч.' (Yi вычисленное) для линейной функции (т.е. решения лин. функции Yi = A*Xi + B, где A и B - полученные коэффициенты полинома)
    for (int i = 0; i < n; i ++)
    {
        Lin_Y[i] = MatrixLin_4[0] * ArrXY[i][0] + MatrixLin_4[1];
    }

    // Вычисляем массив с DeltaYi ('Delta Yi' = Yi - 'Yi выч.') для линейной функции
    for (int i = 0; i < n; i ++)
    {
        Lin_DeltaY[i] = ArrXY[i][1] - Lin_Y[i];
    }

    // Вычисляем массив с (DeltaYi)^2 и невязку (сумма всех (DeltaYi)^2) для линейной функции
    for (int i = 0; i < n; i ++)
    {
        Lin_DeltaYpow2[i] = pow(Lin_DeltaY[i], 2);
        Residual_Lin += Lin_DeltaYpow2[i];
    }

    // Этап 2. Аппроксимация экспериментальных данных квадратичной функцией

    // Заполняем матрицу коэффициентов линейной системы для квадратичной функции
    MatrixQuad_1[0][0] = TotalXpow4;
    MatrixQuad_1[0][1] = MatrixQuad_1[1][0] = TotalXpow3;
    MatrixQuad_1[0][2] = MatrixQuad_1[1][1] = MatrixQuad_1[2][0] = TotalXpow2;
    MatrixQuad_1[1][2] = MatrixQuad_1[2][1] = TotalX;
    MatrixQuad_1[2][2] = n;
    
    // Заполняем вектор-столбец свободных членов для квадратичной функции
    MatrixQuad_2[0] = TotalProductXpow2Y;
    MatrixQuad_2[1] = TotalProductXY;
    MatrixQuad_2[2] = TotalY;

    // Создаём и заполняем вспомогательную матрицу (3x3) с алгебраическими дополнениями каждого элемента исходной матрицы MatrixQuad_1. Это нужно для вычисления обратной матрицы к матрице MatrixQuad_1
    float MatrixQuad_1_A[3][3]; // MatrixQuad_1_A - вспомогательная матрица (3x3) с алгебраическими дополнениями каждого элемента исходной матрицы MatrixQuad_1
    MatrixQuad_1_A[0][0] = MatrixQuad_1[1][1] * MatrixQuad_1[2][2] - MatrixQuad_1[1][2] * MatrixQuad_1[2][1];
    MatrixQuad_1_A[0][1] = (-1) * (MatrixQuad_1[1][0] * MatrixQuad_1[2][2] - MatrixQuad_1[1][2] * MatrixQuad_1[2][0]);
    MatrixQuad_1_A[0][2] = MatrixQuad_1[1][0] * MatrixQuad_1[2][1] - MatrixQuad_1[1][1] * MatrixQuad_1[2][0];
    MatrixQuad_1_A[1][0] = (-1) * (MatrixQuad_1[0][1] * MatrixQuad_1[2][2] - MatrixQuad_1[0][2] * MatrixQuad_1[2][1]);
    MatrixQuad_1_A[1][1] = MatrixQuad_1[0][0] * MatrixQuad_1[2][2] - MatrixQuad_1[0][2] * MatrixQuad_1[2][0];
    MatrixQuad_1_A[1][2] = (-1) * (MatrixQuad_1[0][0] * MatrixQuad_1[2][1] - MatrixQuad_1[0][1] * MatrixQuad_1[2][0]);
    MatrixQuad_1_A[2][0] = MatrixQuad_1[0][1] * MatrixQuad_1[1][2] - MatrixQuad_1[0][2] * MatrixQuad_1[1][1];
    MatrixQuad_1_A[2][1] = (-1) * (MatrixQuad_1[0][0] * MatrixQuad_1[1][2] - MatrixQuad_1[0][2] * MatrixQuad_1[1][0]);
    MatrixQuad_1_A[2][2] = MatrixQuad_1[0][0] * MatrixQuad_1[1][1] - MatrixQuad_1[0][1] * MatrixQuad_1[1][0];
    // Вычисляем определитель матрицы MatrixQuad_1. Это нужно для вычисления обратной матрицы к матрице MatrixQuad_1
    float MatrixQuad1_det = MatrixQuad_1[0][0] * MatrixQuad_1_A[0][0] + MatrixQuad_1[0][1] *  MatrixQuad_1_A[0][1] + MatrixQuad_1[0][2] * MatrixQuad_1_A[0][2]; // MatrixQuad1_det - определитель матрицы MatrixQuad_1

    // Вычисляем обратную матрицу (3x3) (к MatrixQuad_1) для квадратичной функции
    for (int i = 0; i < 3; i ++)
    {
        for (int k = 0; k < 3; k ++)
        {
            MatrixQuad_3[i][k] = MatrixQuad_1_A[i][k] / MatrixQuad1_det;
        }
    }

    // Вычисляем вектор-столбец коэффициентов полинома для квадратичной функции посредством перемножения обратной матрицы MatrixQuad_3 на вектор-столбец свободных членов MatrixQuad_2
    for (int i = 0; i < 3; i ++)
    {
        MatrixQuad_4[i] = MatrixQuad_3[i][0] * MatrixQuad_2[0] + MatrixQuad_3[i][1] * MatrixQuad_2[1] + MatrixQuad_3[i][2] * MatrixQuad_2[2];
    }

    // Вычисляем массив с 'Yi выч.' (Yi вычисленное) для квадратичной функции (т.е. решения Yi = A*(Xi)^2 + B*Xi + C; где A, B, C - полученные коэффициенты полинома)
    for (int i = 0; i < n; i ++)
    {
        Quad_Y[i] = MatrixQuad_4[0] * pow(ArrXY[i][0], 2) + MatrixQuad_4[1] * ArrXY[i][0] + MatrixQuad_4[2];
    }

    // Вычисляем массив с DeltaYi ('Delta Yi' = Yi - 'Yi выч.') для квадратичной функции
    for (int i = 0; i < n; i ++)
    {
        Quad_DeltaY[i] = ArrXY[i][1] - Quad_Y[i];
    }

    // Вычисляем массив с (DeltaYi)^2 и невязку (сумма всех (DeltaYi)^2) для квадратичной функции
    for (int i = 0; i < n; i ++)
    {
        Quad_DeltaYpow2[i] = pow(Quad_DeltaY[i], 2);
        Residual_Quad += Quad_DeltaYpow2[i];
    }

    // Этап 3. Вывод таблиц расчётов, полученных уравнений и невязок.

    // Этап 3_1. Вывод таблиц расчётов для линейной функции, а также полученного уравнения и невязки.

    // Вывод заголовка и 'шапки' основной таблицы для линейной функции
    cout << setw(151) << right << "Аппроксимация экспериментальных данных линейной функцией:" << endl;
    cout << "┌" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" 
    << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┐" << endl;
    cout << "│" << setw(10) << right << "xᵢ" << setw(8) << "│" << setw(10) << "yᵢ" << setw(8) << "│" << setw(11) << "xᵢ²" << setw(8) << "│" << setw(11) 
    << "xᵢ³" << setw(8) << "│" << setw(12) << "xᵢ⁴" << setw(8) << "│" << setw(15) << "xᵢ∗yᵢ" << setw(7) << "│" << setw(17) << "xᵢ²∗yᵢ" << setw(6) << "│" 
    << setw(15) << "yᵢ выч." << setw(6) << "│" << setw(11) << "Δyᵢ" << setw(8) << "│" << setw(14) << "(Δyᵢ)²" << setw(6) << "│"<< endl;
    cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" 
    << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤" << endl;

    // cout << setprecision(5); // Вывод не более пяти значащих разрядов в числах. По умолчанию стоит вывод не более 6 знач. разрядов.
    
    // Вывод 'тела' основной таблицы для линейной функции
    for (int i = 0; i < n; i ++)
    {
        cout << "│" << setw(13) << left << ArrXY[i][0] << "│" << setw(13) << ArrXY[i][1] << "│" << setw(13) << Xpow2[i] << "│" 
        << setw(13) << Xpow3[i] << "│" << setw(13) << Xpow4[i] << "│" << setw(13) << ProductXY[i] << "│" << setw(13) << ProductXpow2Y[i] 
        << "│" << setw(13) << Lin_Y[i] << "│" << setw(13) << Lin_DeltaY[i]  << "│" << setw(13) << Lin_DeltaYpow2[i]  << "│" << endl;
        cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" 
        << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
    }

    // Вывод низа основной таблицы для линейной функции
    cout << "│" << setw(12) << right << "Σxᵢ:" << setw(7) << "│" << setw(12) << "Σyᵢ:" << setw(7) << "│" << setw(13) << "Σxᵢ²:" << setw(7) 
    << "│" << setw(13) << "Σxᵢ³:" << setw(7) << "│" << setw(14) << "Σxᵢ⁴:" << setw(7) << "│" << setw(17) << "Σxᵢ∗yᵢ:" << setw(6) << "│" 
    << setw(19) << "Σxᵢ²∗yᵢ:" << setw(5) << "│" << setw(16) << "│" << setw(16) << "│" << setw(18) << "Невязка:" << setw(5) << "│"<< endl;
    cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" 
    << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
    cout << "│" << setw(13) << left << TotalX << "│" << setw(13) << TotalY << "│" << setw(13) << TotalXpow2 << "│" << setw(13) 
    << TotalXpow3 << "│" << setw(13) << TotalXpow4 << "│" << setw(13) << TotalProductXY << "│" << setw(13) << TotalProductXpow2Y 
    << "│" << right << setw(16) << "│" << setw(16) << "│" << left << setw(13) << Residual_Lin << "│" << endl;
    cout << "└" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────"<< "┴" << "─────────────" 
    << "┴" << "─────────────" << "┴" << "─────────────"<< "┴" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────" << "┘" << endl;

    // Вывод двух дополнительных таблиц для линейной функции
    cout << setw(50) << right << "Матрица коэфф. лин. системы" << setw(43) << "Свободные члены" << endl;
    cout << "┌" << "─────────────" << "┬" << "─────────────" << "┐" << setw(16) << right << "┌" << "─────────────" << "┐" << endl;
    for (int i = 0; i < 2; i ++)
    {
        cout << "│" << setw(13) << left << MatrixLin_1[i][0] << "│" << setw(13) << MatrixLin_1[i][1] << "│" << setw(16) << right << "│" << setw(13) << left << MatrixLin_2[i] << "│" << endl;
        
        if (i + 1 == 2) // На последней итерации должен выводиться закрывающийся элемент таблицы. Для этого такое условие.
        {
            cout << "└" << "─────────────" << "┴" << "─────────────" << "┘"<< setw(16) << right << "└" << "─────────────" << "┘" << endl;
        }
        else
        {
            cout << "├" << "─────────────" << "┼" << "─────────────" << "┤"<< setw(16) << right << "├" << "─────────────" << "┤" << endl;
        }
    }

    // Вывод ещё двух дополнительных таблиц для линейной функции
    cout << setw(38) << right << "Обратная матрица" << setw(47) << "Коэфф. полинома" << endl;
    cout << "┌" << "─────────────" << "┬" << "─────────────" << "┐" << setw(16) << right << "┌" << "─────────────" << "┐" << endl;
    for (int i = 0; i < 2; i ++)
    {
        cout << "│" << setw(13) << left << MatrixLin_3[i][0] << "│" << setw(13) << MatrixLin_3[i][1] << "│" << setw(16) << right << "│" << setw(13) << left << MatrixLin_4[i] << "│" << endl;
        
        if (i + 1 == 2) // На последней итерации должен выводиться закрывающийся элемент таблицы. Для этого такое условие.
        {
            cout << "└" << "─────────────" << "┴" << "─────────────" << "┘"<< setw(16) << right << "└" << "─────────────" << "┘" << endl;
        }
        else
        {
            cout << "├" << "─────────────" << "┼" << "─────────────" << "┤"<< setw(16) << right << "├" << "─────────────" << "┤" << endl;
        }
    }
    
    // Вывод полученного уравнения и невязки для линейной функции.
    // Дополнительное условие. Если коэффициенты отрицательны, то они заключаются в скобочки.
    if (MatrixLin_4[1] < 0)
    {
        cout << "Ответ: \nПолученное линейное уравнение: y = " << MatrixLin_4[0] << "∗x + " << "(" << MatrixLin_4[1] << ")" << "; невязка Q = " << Residual_Lin << "\n" << endl;
    }
    else
    {
        cout << "Ответ: \nПолученное линейное уравнение: y = " << MatrixLin_4[0] << "∗x + " << MatrixLin_4[1] << "; невязка Q = " << Residual_Lin << "\n" << endl;
    }

    // Этап 3_2. Вывод таблиц расчётов для квадратичной функции, а также полученное уравнение и невязку.

    // Вывод заголовка и 'шапки' основной таблицы для квадратичной функции
    cout << setw(150) << right << "Аппроксимация экспериментальных данных квадратичной функцией:" << endl;
    cout << "┌" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" 
    << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┐" << endl;
    cout << "│" << setw(10) << right << "xᵢ" << setw(8) << "│" << setw(10) << "yᵢ" << setw(8) << "│" << setw(11) << "xᵢ²" << setw(8) << "│" << setw(11) 
    << "xᵢ³" << setw(8) << "│" << setw(12) << "xᵢ⁴" << setw(8) << "│" << setw(15) << "xᵢ∗yᵢ" << setw(7) << "│" << setw(17) << "xᵢ²∗yᵢ" << setw(6) 
    << "│" << setw(15) << "yᵢ выч." << setw(6) << "│" << setw(11) << "Δyᵢ" << setw(8) << "│" << setw(14) << "(Δyᵢ)²" << setw(6) << "│"<< endl;
    cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" 
    << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤" << endl;

    // Вывод 'тела' основной таблицы для квадратичной функции
    for (int i = 0; i < n; i ++)
    {
        cout << "│" << setw(13) << left << ArrXY[i][0] << "│" << setw(13) << ArrXY[i][1] << "│" << setw(13) << Xpow2[i] << "│" << setw(13) 
        << Xpow3[i] << "│" << setw(13) << Xpow4[i] << "│" << setw(13) << ProductXY[i] << "│" << setw(13) << ProductXpow2Y[i] << "│" 
        << setw(13) << Quad_Y[i] << "│" << setw(13) << Quad_DeltaY[i]  << "│" << setw(13) << Quad_DeltaYpow2[i]  << "│" << endl;
        cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" 
        << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
    }

    // Вывод низа основной таблицы для квадратичной функции
    cout << "│" << setw(12) << right << "Σxᵢ:" << setw(7) << "│" << setw(12) << "Σyᵢ:" << setw(7) << "│" << setw(13) << "Σxᵢ²:" << setw(7) 
    << "│" << setw(13) << "Σxᵢ³:" << setw(7) << "│" << setw(14) << "Σxᵢ⁴:" << setw(7) << "│" << setw(17) << "Σxᵢ∗yᵢ:" << setw(6) << "│" 
    << setw(19) << "Σxᵢ²∗yᵢ:" << setw(5) << "│" << setw(16) << "│" << setw(16) << "│" << setw(18) << "Невязка:" << setw(5) << "│"<< endl;
    cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" 
    << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
    cout << "│" << setw(13) << left << TotalX << "│" << setw(13) << TotalY << "│" << setw(13) << TotalXpow2 << "│" << setw(13) 
    << TotalXpow3 << "│" << setw(13) << TotalXpow4 << "│" << setw(13) << TotalProductXY << "│" << setw(13) << TotalProductXpow2Y 
    << "│" << right << setw(16) << "│" << setw(16) << "│" << left << setw(13) << Residual_Quad << "│" << endl;
    cout << "└" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────"<< "┴" << "─────────────" << "┴" 
    << "─────────────" << "┴" << "─────────────"<< "┴" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────" << "┘" << endl;

    // Вывод двух дополнительных таблиц для квадратичной функции
    cout << setw(76) << right << "Матрица коэффициентов линейной системы" << setw(44) << "Свободные члены" << endl;
    cout << "┌" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┐" << setw(16) << right << "┌" << "─────────────" << "┐" << endl;
    for (int i = 0; i < 3; i ++)
    {
        cout << "│" << setw(13) << left << MatrixQuad_1[i][0] << "│" << setw(13) << MatrixQuad_1[i][1] << "│" << setw(13) 
        << MatrixQuad_1[i][2] << "│" << setw(16) << right << "│" << setw(13) << left << MatrixQuad_2[i] << "│" << endl;
        
        if (i + 1 == 3) // На последней итерации должен выводиться закрывающийся элемент таблицы. Для этого такое условие.
        {
            cout << "└" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────" << "┘"<< setw(16) << right << "└" << "─────────────" << "┘" << endl;
        }
        else
        {
            cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤"<< setw(16) << right << "├" << "─────────────" << "┤" << endl;
        }
    }

    // Вывод ещё двух дополнительных таблиц для квадратичной функции
    cout << setw(45) << right << "Обратная матрица" << setw(54) << "Коэфф. полинома" << endl;
    cout << "┌" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┐" << setw(16) << right << "┌" << "─────────────" << "┐" << endl;
    for (int i = 0; i < 3; i ++)
    {
        cout << "│" << setw(13) << left << MatrixQuad_3[i][0] << "│" << setw(13) << MatrixQuad_3[i][1] << "│" << setw(13) 
        << MatrixQuad_3[i][2] << "│" << setw(16) << right << "│" << setw(13) << left << MatrixQuad_4[i] << "│" << endl;
        
        if (i + 1 == 3) // На последней итерации должен выводиться закрывающийся элемент таблицы. Для этого такое условие.
        {
            cout << "└" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────" << "┘"<< setw(16) << right << "└" << "─────────────" << "┘" << endl;
        }
        else
        {
            cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤"<< setw(16) << right << "├" << "─────────────" << "┤" << endl;
        }
    }
    
    // Вывод полученного уравнения и невязки для квадратичной функции.
    // Дополнительное условие. Если коэффициенты отрицательны, то они заключаются в скобочки.
    if (MatrixQuad_4[1] < 0 && MatrixQuad_4[2] < 0)
    {
        cout << "Ответ: \nПолученное квадратичное уравнение: y = " << MatrixQuad_4[0] << "∗x² + " << "(" << MatrixQuad_4[1]  
        << ")" << "∗x + " << "(" << MatrixQuad_4[2] << ")" << "; невязка Q = " << Residual_Quad << "\n" << endl;
    }
    else if (MatrixQuad_4[1] < 0)
    {
        cout << "Ответ: \nПолученное квадратичное уравнение: y = " << MatrixQuad_4[0] << "∗x² + " << "(" << MatrixQuad_4[1]  
        << ")" << "∗x + " << MatrixQuad_4[2] << "; невязка Q = " << Residual_Quad << "\n" << endl;
    }
    else if (MatrixQuad_4[2] < 0)
    {
        cout << "Ответ: \nПолученное квадратичное уравнение: y = " << MatrixQuad_4[0] << "∗x² + " << MatrixQuad_4[1] 
        << "∗x + " << MatrixQuad_4[2] << "; невязка Q = " << Residual_Quad << "\n" << endl;
    }
    else
    {
        cout << "Ответ: \nПолученное квадратичное уравнение: y = " << MatrixQuad_4[0] << "∗x² + " << MatrixQuad_4[1] 
        << "∗x + " << MatrixQuad_4[2] << "; невязка Q = " << Residual_Quad << "\n" << endl;
    }

    return 0;
}