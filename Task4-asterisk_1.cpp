// Гурьянов Илья, гр. 1/147.
// Задание №4*, номер 1, вариант 6.            (в названии программы 'asterisk' с английского значит "звёздочка" (знак *))
// Программа локализует и уточняет корень заданного уравнения.

#include <iostream>
#include <Windows.h>
#include <cmath>
#include <iomanip>

using namespace std;

int main()
{
    // Локализация (отображение кириллицы в консоли)
    SetConsoleCP(65001);
    SetConsoleOutputCP(65001);

    float x1 = -1; // x1 - начало отрезка, т.е. 'a' в отрезке [a; b]
    float x2 = -1; // x2 - конец отрезка, т.е. 'b' в отрезке [a; b]
    float step = 0; // step - шаг (приращение x)
    float compare; // compare - сравнение. Третья переменная (буфер) для того, чтобы поменять значение двух переменных между собой
    float y; // y - y(x), значение функции
    float eps = 0.0001; // eps - (epsilon), точность
    int number; // number - количество шагов (в отрезке [a;b] при заданном приращении)
    const float Pi = acos(-1); // Pi - константа Пи 3,14... (находится через обратную тригонометрическую функцию)
    float blizkoren1, blizkoren2; // "близкий корень 1", "близкий корень 2"; т.е. локализация корня в отрезке [blizkoren1; blizkoren2]
    int trigger = 0; // trigger - триггер. Принимает значения: 0, 1, 2, где 0 - корней нет, 1 - есть один корень, 2 - есть несколько корней
    float a, b, c; // Переменные для второго этапа. 'a' и 'b' - отрезок [a; b], в котором уточняется корень; c - середина отрезка (c = (a + b)/2)
    float fa, fc; // f(a), f(b) - значение заданной функции в точках 'a' и 'c'
    int extra = 0; // extra - количество дополнительных корней на заданном отрезке
    float product; // product - произведение f(a)*f(c)

    // Первый этап. Локализация корня.

    // Ввод отрезка с клавиатуры. Область определения функции: x > -1. 
    // Защита от ввода одинаковых чисел и чисел за пределами области определения. Защита от ввода букв не реализована. Если ввести буквы - то, к сожалению, получается бесконечный цикл.
    while (x1 == x2 || x1 <= -1 || x2 <= -1)
    {
    cout << "Введите отрезок на оси абсцисс (ось x), (x > -1) (вводить через пробел): ";
    cin >> x1 >> x2;

    }
    // Если пользователь ввёл числа не по возрастанию (a >= b) в отрезке [a; b], программа меняет их местами. Тогда отрицательный шаг уже нельзя будет ввести.
    if (x2 < x1)
    {
        cout << "Вы ввели числа не по возрастанию. По определению, в отрезке [a, b] a <= b. Программа уже поменяла их местами, Вам не о чем беспокоиться." << endl;
        compare = x1;
        x1 = x2;
        x2 = compare;
    }
    // Ввод шага (приращения x). Защита от ввода нулевого или отрицательного шага. Защита от ввода букв также отсутсвует, а при их вводе, к сожалению - бесконечный цикл.
    while (step <= 0)
    {
        cout << "Введите шаг x: ";
        cin >> step;
        if (step == 0)
        {
            cout << "Шаг не может быть нулевым." << endl;
        }
        if (step < 0)
        {
            cout << "Шаг не может быть отрицательным. По определению, в отрезке [a, b] a <= b, поэтому отрицательный шаг не может существовать." << endl;
        }
    }
    // Вывод полученного отрезка и шага, введённых пользователем.
    cout << "Отрезок [" << x1 << "; " << x2 << "] с шагом " << step << endl;

    // Вычисляем количество шагов в заданном отрезке с заданным приращением.
    if (x1 >= 0 && x2 >= 0) // если "концы" отрезка >= 0
    {
        number = floor((x2 - x1) / step) + 1; // добавляю '+ 1'; без '+ 1' это получится количество шагов в полуинтервале, а не отрезке, т.е. не войдёт первый конец
    }
    else if (x1 < 0 && x2 >= 0) // если один из "концов" отрезка отрицательный (тогда второй "конец" априори >= 0, т.к. они расположены по возрастанию)
    {
        number = floor((abs(x1) + x2) / step) + 1;
    }
    else // (x1 < 0 && x2 < 0) - если оба "конца" отрезка < 0
    {
        number = floor((abs(x1) - abs(x2)) / step) + 1;
    }
    float Arr[number][2]; // Двумерный массив, куда будем записывать полученный 'x' и 'y' функции на каждой итерации.
    int m = 0; // счётчик для 'x' для двумерного массива (в цикле) 

    // Вывод 'шапки' первой таблицы
    cout << "┌" << "─────────────" << "┬" << "─────────────" << "┐" << endl;
    cout << "│" << setw(7) << "x" << setw(9) << "│" << setw(7) << "y" << setw(9) << "│" << endl;
    cout << "├" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
    // Вычисляем значение функции в заданном интервале с заданным шагом. Записываем 'x' и 'y' функции в двумерный массив. Выводим таблицой.
    for (float i = x1; i <= x2; i += step)
    {
        // Из-за появляющейся неточности чисел с плавающей точкой, возможно невыполнение последней итерации 
        // (к примеру в отрезке [-0.3; 2] с шагом 0.1, не выполняется последняя итерация при x = 2, хотя он входит в отрезок, последняя выполняемая итерация при x = 1.9
        // В 4-ой по счёту итерации, когда x = -0.1 переходит в 0, в этом нуле появляется какой-то мусор (погрешность).
            // cout << "i = " << i << "(i + step = " << i+step << ")" << endl;
        y = sqrt(i + 1) - 2 * cos((Pi * i) / 2);
        Arr[m][1] = y;
        Arr[m][0] = i;
        m += 1;
        cout << "│" << setprecision(5) << setw(13) << left << i << "│" << setw(13) << y << "│" << endl;
                // Костыль, чтобы совершалась последняя итерация. Почему-то не работает.
                // if ((i + step) != x2 && abs((i + step) - x2) < 0.0000001) // сравнение последнего шага 'x' с конечным 'x' отрезка, с точностью eps = 1e-7
                // {
                //     cout << "├" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
                //     y = sqrt((i + step) + 1) - 2 * cos((Pi * (i + step)) / 2);
                //     Arr[m][1] = y;
                //     Arr[m][0] = (i + step);
                //     m += 1;
                //     cout << "│" << setprecision(5) << setw(13) << left << (i + step) << "│" << setw(13) << y << "│" << endl;
                // }
        if (i + step > x2) // На последней итерации должен вывестись закрывающийся элемент таблицы. Для этого такое условие.
        {
            cout << "└" << "─────────────" << "┴" << "─────────────" << "┘" << endl;
        }
        else
        {
            cout << "├" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
        }
    }
    // Сравниваем соседние значения ('y') функции. Если находятся соседние значения, между которыми происходит смена знака, запоминаем их в переменные blizkoren1, blizkoren2.
    // Программа запоминает только первую входящую локализацию корня в заданном отрезке. В функции в варианте 6 существует два корня.
    for (int i = 0; i < number - 1; i ++)
    {
            // cout << "i = " << i << endl;
        // Сравниваем текущий и следующий элемент массива.
                // Есть вероятность "условного выхода" за пределы массива, в самой последней итерации, последний элемент массива Arr[i+1][1] может быть равен 0. 
                // Из-за той неточности с числами с плавающей точкой в этот последний элемент массива ничего не записалось, хотя должно было, поэтому он так и остался нулевым.
                // Но вроде на правильность локализации и уточнения корня не влияет.
        if ((Arr[i+1][1] > 0 && Arr[i][1] < 0) || (Arr[i+1][1] < 0 && Arr[i][1] > 0)) 
        {
            if (trigger == 0)
            {
                blizkoren1 = Arr[i][0];
                blizkoren2 = Arr[i+1][0];
                trigger = 1;
            }
            else // (trigger == 1 || trigger == 2) - если находится вторая локализация (т.е. отрезок на котором меняется знак) и последующие, то только записываем кол-во этих дополнительных корней.
            {
                trigger = 2;
                extra ++;
            }  
        }
        // if (Arr[i][1] == 0 || Arr[i+1][1] == 0) // На всякий случай. Если уже нашёлся корень, то программа завершается. Но такой случай в данной функции невозможен. Не работает из-за той проблемы сверху.
        // {
        //         // cout << Arr[i][1] << endl;
        //         // cout << Arr[i+1][1] << endl;
        //         // cout << i << "; " << i+1 << endl;
        //         // cout << "number = " << number << endl
        //     exit(1);
        // }
    }
    // Выводим локализирующий отрезок, сообщения об отсутсвии корней или наличии дополнительных корней.
    if (trigger == 1)
    {
        cout << "Корень лежит в пределах отрезка: " << "[" << blizkoren1 << "; " << blizkoren2 << "]" << endl;
    }
    else if (trigger == 0)
    {
        cout << "В данном отрезке нет корней." << endl;
        exit(1); // Если нет корней, досрочно завершаем программу.
    }
    else
    {
        cout << "Корень лежит в пределах отрезка: " << "[" << blizkoren1 << "; " << blizkoren2 << "]" << endl;
        cout << "Внимание! Программа нашла ещё " << extra << " корень(ней). ";
        cout << "Но показывать его (их) она, конечно же, не будет. Программа выводит только первый входящий в отрезок корень." << endl;
    }

    // Второй этап. Уточнение корня.
    
    // Уточняем корень в локализованном отрезке [a; b], где a = blizkoren1, b = blizkoren2.
    a = blizkoren1;
    b = blizkoren2;
    int iter = 0; // iter - (iterations), количество итераций, затраченных для уточнения корня
    // Вывод "шапку" второй таблицы.
    cout << "┌" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┬" << "─────────────" << "┐" << endl;
    cout << "│" << setw(7) << right << "a" << setw(9) << "│" << setw(7) << "b" << setw(9) << "│" << setw(7) << "c" << setw(9) << "│" 
    << setw(8) << "b-a" << setw(8) << "│" << setw(9) << "f(a)" << setw(7) << "│" << setw(9) << "f(c)" << setw(7) << "│" << setw(11) << "f(a)*f(c)" << setw(5) << "│" << endl;
    cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
    // Уточняем корень по данному в задании алгоритму. Выводим таблицу расчётов.
    while (abs(b - a) > eps)
    {
        iter ++; // счётчик итераций
        c = (a + b) / 2; // середина отрезка
        fa = sqrt(a + 1) - 2 * cos((Pi * a) / 2); // Значение функции в точке 'a'
        fc = sqrt(c + 1) - 2 * cos((Pi * c) / 2); // Значение функции в точке 'c'
        product = fa * fc; // произведение f(a)*f(c)
        cout << "│" << setw(13) << left << a << "│" << setw(13) << b << "│" << setw(13) << c << "│" 
        << setw(13) << b-a << "│" << setw(13) << fa << "│" << setw(13) << fc << "│" << setw(13) << product << "│" << endl;
        // Сравниваем произведение f(a)*f(c) относительно нуля.
        if (product < 0)
        {
            a = blizkoren1;
            b = c;
        }
        else if (product > 0)
        {
            a = c;
            // b = b;
        }
        else // (product == 0) - На всякий случай. Если произведение окажется равно нулю, программа завершится.
        {
            cout << "Меня к такому не готовили. Я выхожу." << endl;
            exit(1);
        }
        if (abs(b - a) <= eps) // На последней итерации должен вывестись закрывающийся элемент таблицы. Для этого такое условие.
        {
            cout << "└" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────"<< "┴" << "─────────────" << "┴" << "─────────────" << "┴" << "─────────────" << "┘" << endl;
        }
        else
        {
            cout << "├" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────"<< "┼" << "─────────────" << "┼" << "─────────────" << "┼" << "─────────────" << "┤" << endl;
        }
    }
    // Вывод уточнённого корня и количество совершённых итераций.
    cout << "Корень = " << c << endl;
    cout << "На операцио уточнения корня с точностью eps = 0.0001 было затрачено " << iter << " итерации(й)." << endl;

    return 0;
}
